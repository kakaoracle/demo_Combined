# <多处理器编程的艺术>
## 互斥
互斥:      不同线程的临界区不重叠(获取锁这个操作)
无死锁:    总能获取到锁
无饥饿:    
- 临界区:标识符的读写,比如线程1lock,但是解锁过程中线程2又lock,则锁是开着的还是关着的?
## 多线程与变量
- 每一个线程都会在执行方法时生成一份自己的栈,因此多线程会影响到成员变量,无论是private还是public
    但是多线程不会影响到局部变量


## 并发对象
- volatile(挥发): 对一个volatile域的读就如同获得一个锁,工作区被置为无效
  对一个volatile域的写就如同释放一个锁,值立即被写回工作区   
  但是仅仅是如同,实际并不是,比如多个读写操作时,并不是原子的
  常用范围是多读一写
- 

## 共享存储器基础
- 在硬件层,线程是通过读/写共享存储器进行通信的,而如果用互斥的话,所有的寄存器在读
写的时候都需要依赖系统调度器,完全的没有意义,因此提出一个没有任何形式的互斥,能够
保证独立地演进,实现无等待(指不用寄存器),即原子寄存器.
- 写与读操作本身耗费的时间一般非常长
    比如写完0,在写1的过程中,两个线程顺序读取,读到0与1都是可能的,因为无法确定什么时间写完
- SeqSnapShot能够实现无等待的核心是scan()方法调用能够返回多个值

## 同步原子操作的相对能力

## 一致性的通用性

## 自旋锁与争用

## 管程与阻塞同步

## 链表:锁的作用

## 并行队列和ABA问题

## 并发栈和消除

## 计数,排序和分布式协作

## 第13章 并发哈希和固有并行

## 第14章 跳表和平衡查找

## 第15章 优先级队列

## 第16章 异步执行,调度和工作分配

## 第17章 障碍

## 第18章 事务内存



