# <多处理器编程的艺术>
## 互斥
互斥:      不同线程的临界区不重叠(获取锁这个操作)
无死锁:    总能获取到锁
无饥饿:    
- 临界区:标识符的读写,比如线程1lock,但是解锁过程中线程2又lock,则锁是开着的还是关着的?
        因此临界区应该定义为,上锁方法中的一句不是原子操作的代码.
- 关于Peterson锁:这是一个标准的适用于两个线程的锁,一个数组用来装两个线程开头,一个
两个线程完全透明的标识位,判断时两个条件,如果数组中另一个线程为true,那么证明另一个线程在用
对于主线程来讲,如果混淆线程不动,则根据数组flag[j]为false确定上锁成功,如果混淆线程动,那么
再根据标识符i被改动为了混淆线程确定主线程也上锁成功.
即,不动,则数组不动,则主线程上锁成功,动,则标识符改变,收主线程也上锁成功


## 多线程与变量
- 每一个线程都会在执行方法时生成一份自己的栈,因此多线程会影响到成员变量,无论是private还是public
    但是多线程不会影响到局部变量


## 并发对象
- volatile(挥发): 对一个volatile域的读就如同获得一个锁,工作区被置为无效
  对一个volatile域的写就如同释放一个锁,值立即被写回工作区   
  但是仅仅是如同,实际并不是,比如多个读写操作时,并不是原子的
  常用范围是多读一写
- 

## 共享存储器基础
- 在硬件层,线程是通过读/写共享存储器进行通信的,而如果用互斥的话,所有的寄存器在读
写的时候都需要依赖系统调度器,完全的没有意义,因此提出一个没有任何形式的互斥,能够
保证独立地演进,实现无等待(指不用寄存器),即原子寄存器.
- 写与读操作本身耗费的时间一般非常长
    比如写完0,在写1的过程中,两个线程顺序读取,读到0与1都是可能的,因为无法确定什么时间写完
- SeqSnapShot能够实现无等待的核心是scan()方法调用能够返回多个值

## 同步原子操作的相对能力
## 一致性的通用性
## 自旋锁与争用
- 任何互斥协议都会产生这样的问题:如果不能获得锁,应该怎么做?
    继续尝试-->这种叫自旋锁
- 不用第二章的Peterson锁算法的原因是,数组flag与标识符的victim读写顺序不会和程序中相同
为了避免编译器的重排序,需要设计新的模式

   
- 总线:
    一条线,连接多个线程,任一时刻只能有一个线程在传播,其他线程都在监听,每个线程拥有自己的一个小存储cache
    总线传播:死循环,极快速将线程A(已上锁)为true写入到其他每一个线程的cache中
    本地旋转:循环读取自己cache的值,而不是向总线读取
    高争用:锁释放后,总线会写入false,多个线程读取到时全部进行争用,同时只能有一个线程上锁成功,该线程再释放锁
            ,剩下的再进行争用......
            多个线程同时争用会消耗资源的原因是一个线程会伴随着一个上下文,上下文的开销大
- 锁的后退:   
    一个锁存在着高急用,那么线程就不应该高争用,而应该后退一点时间
    策略是: 1,发现锁变为空闲,但是自己获取不到, 2,第一次获取不到加延迟时间,第二次获取不到再延长
    
    
- 引入一个队列锁
    用数组,就是之前两个线程有一个标识符victim,现在victim变成了victim[],死循环仍不变
    解决问题:缩短线程释放锁与另一个线程获得锁之间的时间间隔
    特点,队列锁提供了先来先服务的公平性
-  引入复合锁(composite lock)
    没有哪一种算法能够适用于所有的应用,因此没有完美的锁



   
    
   
    
    
## 管程与阻塞同步
1. 概念:
    管程是将同步和数据结合,类似于类将数据和方法封装为一个整体
    线程无法获得锁时:或者自旋,或者阻塞(不再反复判断锁能否被获取,冻结在队列中)
    当一个锁被持有,那么正在等待的线程应该自旋
    
    await()作用就是释放锁,进入阻塞区
    
    可重入锁(ReentrantLock):持有锁的线程在获取锁失败后不被算法分配到阻塞区而重新获取锁,其实也就是自旋.
    
    
2. Lock接口
```java
    import java.util.concurrent.locks.Condition;public interface Lock{
        void lock();
        void lockInterruptibly() throws InterruptedException;
        boolean tryLock();
        boolean tryLock(long time,TimeUnit unit);
        Condition newCondition();
        void unlock();
    }
```
3.  
    
## 链表:锁的作用


## 并行队列和ABA问题
1. 无锁的无界队列
LockFreeQueue<T>类是一个由结点组成的链表,每一个结点:
```java
    public class Node{
        public T value;
        public AtomicReference<Node> next;
        public Node(T value){
            this.value = value;
            this.next = new AtomicReference<Node>(null);
        }
    }

```


2. ABA问题
在利用CAS过程中,中心就是判断与上次值相等,则进行修改,但是对于同一个值A,可能修改为B,
然后第二次被修改为A,这样与上次值依旧相等,这样会漏掉中间的过程,案例:
小明原有200元,提款100元
存取款机1:余额200,将要更新为100
存取款机2:余额200,将要更新为100
提款款机1成功执行,提款机2异常block,这时小红给小明存款100
存取款机1:余额100,将要更新为200
存取机1成功执行,余额变为200
存取款机2恢复,cas后发现是200,那么减100
最终小明余额应为200,实为100

解决方案:对每个原子引用附上一个唯一的时间戳
176




## 并发栈和消除

## 计数,排序和分布式协作

## 第13章 并发哈希和固有并行
1040623285@qq.com




## 第14章 跳表和平衡查找

## 第15章 优先级队列

## 第16章 异步执行,调度和工作分配

## 第17章 障碍

## 第18章 事务内存

## 其他
1. Long类型赋值不是原子操作比如Long foo = 4154435L;因为long是8个字节,要先写4个,再写4个
2. 实现无锁(lock-free)的非阻塞算法有多种实现方法,比如CAS,也是一个乐观锁,语义是:
    我认为V的值应该是A,如果是,那么V的值将更新为B,否则不告诉且不修改V的值
    具体实现:
    int compare_and_swap(int* reg,int oldval,int newval){
        ATOMIC();
        int old_reg_val = *reg;
        if (old_reg_val == oldval)
            *reg = newval;
        END_ATOMIC();
        return old_reg_val;
    }
3. 减少线程的上下文切换的方法
    A, 无锁并发编程:多每种竞争锁时,会引起上下文切换,所以在使用多线程处理数据时,比如可以用哈希值进行切分,不同线程处理不同段的数据
    B, 锁分离技术: ConcurrentHashMap
    C, CAS算法,Atomic包使用cas算法来更新数据,而不需要加锁
        







